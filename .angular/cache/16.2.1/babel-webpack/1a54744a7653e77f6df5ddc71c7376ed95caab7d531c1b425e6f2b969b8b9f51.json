{"ast":null,"code":"import _defineProperty from \"D:/r/class record/TDH APP/cyber-mobile/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Component, Input, TemplateRef, inject, ChangeDetectorRef, ElementRef, ViewContainerRef, Renderer2, Directive, Pipe, NgModule, makeEnvironmentProviders, APP_INITIALIZER } from '@angular/core';\nimport { of, take, from, map, Subject, BehaviorSubject, forkJoin, retry, tap, catchError, shareReplay, switchMap, combineLatest, EMPTY } from 'rxjs';\nimport { unflatten as unflatten$1, flatten as flatten$1 } from 'flat';\nclass DefaultLoader {\n  constructor(translations) {\n    _defineProperty(this, \"translations\", void 0);\n    this.translations = translations;\n  }\n  getTranslation(lang) {\n    return of(this.translations.get(lang) || {});\n  }\n}\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\nfunction getValue(obj, path) {\n  if (!obj) {\n    return obj;\n  }\n  /* For cases where the key is like: 'general.something.thing' */\n  if (Object.prototype.hasOwnProperty.call(obj, path)) {\n    return obj[path];\n  }\n  return path.split('.').reduce((p, c) => p?.[c], obj);\n}\nfunction setValue(obj, prop, val) {\n  obj = {\n    ...obj\n  };\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : {\n        ...acc[part]\n      };\n    }\n    return acc && acc[part];\n  }, obj);\n  return obj;\n}\nfunction size(collection) {\n  if (!collection) {\n    return 0;\n  }\n  if (Array.isArray(collection)) {\n    return collection.length;\n  }\n  if (isObject(collection)) {\n    return Object.keys(collection).length;\n  }\n  return collection ? collection.length : 0;\n}\nfunction isEmpty(collection) {\n  return size(collection) === 0;\n}\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\nfunction isString(val) {\n  return typeof val === 'string';\n}\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\nfunction isObject(item) {\n  return !!item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction coerceArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase()).replace(/\\s+|_|-|\\//g, '');\n}\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\nfunction isDefined(value) {\n  return isNil(value) === false;\n}\nfunction toNumber(value) {\n  if (isNumber(value)) return value;\n  if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n  return null;\n}\nfunction isScopeObject(item) {\n  return item && typeof item.scope === 'string';\n}\nfunction isScopeArray(item) {\n  return Array.isArray(item) && item.every(isScopeObject);\n}\nfunction hasInlineLoader(item) {\n  return item && isObject(item.loader);\n}\nfunction unflatten(obj) {\n  return unflatten$1(obj);\n}\nfunction flatten(obj) {\n  return flatten$1(obj, {\n    safe: true\n  });\n}\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n  providedIn: 'root',\n  factory: () => defaultConfig\n});\nconst defaultConfig = {\n  defaultLang: 'en',\n  reRenderOnLangChange: false,\n  prodMode: false,\n  failedRetries: 2,\n  fallbackLang: [],\n  availableLangs: [],\n  missingHandler: {\n    logMissingKey: true,\n    useFallbackTranslation: false,\n    allowEmpty: false\n  },\n  flatten: {\n    aot: false\n  },\n  interpolation: ['{{', '}}']\n};\nfunction translocoConfig(config = {}) {\n  return {\n    ...defaultConfig,\n    ...config,\n    missingHandler: {\n      ...defaultConfig.missingHandler,\n      ...config.missingHandler\n    },\n    flatten: {\n      ...defaultConfig.flatten,\n      ...config.flatten\n    }\n  };\n}\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nlet DefaultTranspiler = /*#__PURE__*/(() => {\n  var _class2;\n  class DefaultTranspiler {\n    constructor(config) {\n      _defineProperty(this, \"interpolationMatcher\", void 0);\n      this.interpolationMatcher = resolveMatcher(config ?? defaultConfig);\n    }\n    transpile(value, params = {}, translation, key) {\n      if (isString(value)) {\n        return value.replace(this.interpolationMatcher, (_, match) => {\n          match = match.trim();\n          if (isDefined(params[match])) {\n            return params[match];\n          }\n          return isDefined(translation[match]) ? this.transpile(translation[match], params, translation, key) : '';\n        });\n      } else if (params) {\n        if (isObject(value)) {\n          value = this.handleObject(value, params, translation, key);\n        } else if (Array.isArray(value)) {\n          value = this.handleArray(value, params, translation, key);\n        }\n      }\n      return value;\n    }\n    /**\n     *\n     * @example\n     *\n     * const en = {\n     *  a: {\n     *    b: {\n     *      c: \"Hello {{ value }}\"\n     *    }\n     *  }\n     * }\n     *\n     * const params =  {\n     *  \"b.c\": { value: \"Transloco \"}\n     * }\n     *\n     * service.selectTranslate('a', params);\n     *\n     * // the first param will be the result of `en.a`.\n     * // the second param will be `params`.\n     * parser.transpile(value, params, {});\n     *\n     *\n     */\n    handleObject(value, params = {}, translation, key) {\n      let result = value;\n      Object.keys(params).forEach(p => {\n        // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n        const v = getValue(result, p);\n        // get the params of \"b.c\" => { value: \"Transloco\" }\n        const getParams = getValue(params, p);\n        // transpile the value => \"Hello Transloco\"\n        const transpiled = this.transpile(v, getParams, translation, key);\n        // set \"b.c\" to `transpiled`\n        result = setValue(result, p, transpiled);\n      });\n      return result;\n    }\n    handleArray(value, params = {}, translation, key) {\n      return value.map(v => this.transpile(v, params, translation, key));\n    }\n  }\n  _class2 = DefaultTranspiler;\n  _defineProperty(DefaultTranspiler, \"\\u0275fac\", function _class2_Factory(t) {\n    return new (t || _class2)(i0.ɵɵinject(TRANSLOCO_CONFIG, 8));\n  });\n  _defineProperty(DefaultTranspiler, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac\n  }));\n  return DefaultTranspiler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction resolveMatcher(config) {\n  const [start, end] = config.interpolation;\n  return new RegExp(`${start}(.*?)${end}`, 'g');\n}\nfunction getFunctionArgs(argsString) {\n  const splitted = argsString ? argsString.split(',') : [];\n  const args = [];\n  for (let i = 0; i < splitted.length; i++) {\n    let value = splitted[i].trim();\n    while (value[value.length - 1] === '\\\\') {\n      i++;\n      value = value.replace('\\\\', ',') + splitted[i];\n    }\n    args.push(value);\n  }\n  return args;\n}\nlet FunctionalTranspiler = /*#__PURE__*/(() => {\n  var _class3;\n  class FunctionalTranspiler extends DefaultTranspiler {\n    constructor(injector) {\n      super();\n      _defineProperty(this, \"injector\", void 0);\n      this.injector = injector;\n    }\n    transpile(value, params = {}, translation, key) {\n      let transpiled = value;\n      if (isString(value)) {\n        transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*?)\\)\\s*]]/g, (match, functionName, args) => {\n          try {\n            const func = this.injector.get(functionName);\n            return func.transpile(...getFunctionArgs(args));\n          } catch (e) {\n            let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n            if (e.message.includes('NullInjectorError')) {\n              message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n            }\n            throw new Error(message);\n          }\n        });\n      }\n      return super.transpile(transpiled, params, translation, key);\n    }\n  }\n  _class3 = FunctionalTranspiler;\n  _defineProperty(FunctionalTranspiler, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵinject(i0.Injector));\n  });\n  _defineProperty(FunctionalTranspiler, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class3,\n    factory: _class3.ɵfac\n  }));\n  return FunctionalTranspiler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nlet DefaultHandler = /*#__PURE__*/(() => {\n  var _class4;\n  class DefaultHandler {\n    handle(key, config) {\n      if (config.missingHandler.logMissingKey && !config.prodMode) {\n        const msg = `Missing translation for '${key}'`;\n        console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n      }\n      return key;\n    }\n  }\n  _class4 = DefaultHandler;\n  _defineProperty(DefaultHandler, \"\\u0275fac\", function _class4_Factory(t) {\n    return new (t || _class4)();\n  });\n  _defineProperty(DefaultHandler, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class4,\n    factory: _class4.ɵfac\n  }));\n  return DefaultHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nlet DefaultInterceptor = /*#__PURE__*/(() => {\n  var _class5;\n  class DefaultInterceptor {\n    preSaveTranslation(translation) {\n      return translation;\n    }\n    preSaveTranslationKey(_, value) {\n      return value;\n    }\n  }\n  _class5 = DefaultInterceptor;\n  _defineProperty(DefaultInterceptor, \"\\u0275fac\", function _class5_Factory(t) {\n    return new (t || _class5)();\n  });\n  _defineProperty(DefaultInterceptor, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class5,\n    factory: _class5.ɵfac\n  }));\n  return DefaultInterceptor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nlet DefaultFallbackStrategy = /*#__PURE__*/(() => {\n  var _class6;\n  class DefaultFallbackStrategy {\n    constructor(userConfig) {\n      _defineProperty(this, \"userConfig\", void 0);\n      this.userConfig = userConfig;\n    }\n    getNextLangs() {\n      const fallbackLang = this.userConfig.fallbackLang;\n      if (!fallbackLang) {\n        throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n      }\n      return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n    }\n  }\n  _class6 = DefaultFallbackStrategy;\n  _defineProperty(DefaultFallbackStrategy, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)(i0.ɵɵinject(TRANSLOCO_CONFIG));\n  });\n  _defineProperty(DefaultFallbackStrategy, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class6,\n    factory: _class6.ɵfac\n  }));\n  return DefaultFallbackStrategy;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\nfunction getScopeFromLang(lang) {\n  if (!lang) {\n    return '';\n  }\n  const split = lang.split('/');\n  split.pop();\n  return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\nfunction getLangFromScope(lang) {\n  if (!lang) {\n    return '';\n  }\n  return lang.split('/').pop();\n}\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\nfunction getPipeValue(str, value, char = '|') {\n  if (isString(str)) {\n    const splitted = str.split(char);\n    const lastItem = splitted.pop();\n    return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n  }\n  return [false, ''];\n}\nfunction shouldListenToLangChanges(service, lang) {\n  const [hasStatic] = getPipeValue(lang, 'static');\n  if (!hasStatic) {\n    // If we didn't get 'lang|static' check if it's set in the global level\n    return !!service.config.reRenderOnLangChange;\n  }\n  // We have 'lang|static' so don't listen to lang changes\n  return false;\n}\nfunction listenOrNotOperator(listenToLangChange) {\n  return listenToLangChange ? source => source : take(1);\n}\nfunction prependScope(inlineLoader, scope) {\n  return Object.keys(inlineLoader).reduce((acc, lang) => {\n    acc[`${scope}/${lang}`] = inlineLoader[lang];\n    return acc;\n  }, {});\n}\nfunction resolveInlineLoader(providerScope, scope) {\n  return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : undefined;\n}\nfunction getEventPayload(lang) {\n  return {\n    scope: getScopeFromLang(lang) || null,\n    langName: getLangFromScope(lang)\n  };\n}\nfunction resolveLoader(options) {\n  const {\n    path,\n    inlineLoader,\n    mainLoader,\n    data\n  } = options;\n  if (inlineLoader) {\n    const pathLoader = inlineLoader[path];\n    if (isFunction(pathLoader) === false) {\n      throw `You're using an inline loader but didn't provide a loader for ${path}`;\n    }\n    return inlineLoader[path]().then(res => res.default ? res.default : res);\n  }\n  return mainLoader.getTranslation(path, data);\n}\nfunction getFallbacksLoaders({\n  mainLoader,\n  path,\n  data,\n  fallbackPath,\n  inlineLoader\n}) {\n  const paths = fallbackPath ? [path, fallbackPath] : [path];\n  return paths.map(path => {\n    const loader = resolveLoader({\n      path,\n      mainLoader,\n      inlineLoader,\n      data\n    });\n    return from(loader).pipe(map(translation => ({\n      translation,\n      lang: path\n    })));\n  });\n}\nlet service;\nfunction translate(key, params = {}, lang) {\n  return service.translate(key, params, lang);\n}\nfunction translateObject(key, params = {}, lang) {\n  return service.translateObject(key, params, lang);\n}\nlet TranslocoService = /*#__PURE__*/(() => {\n  var _class7;\n  class TranslocoService {\n    constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n      _defineProperty(this, \"loader\", void 0);\n      _defineProperty(this, \"parser\", void 0);\n      _defineProperty(this, \"missingHandler\", void 0);\n      _defineProperty(this, \"interceptor\", void 0);\n      _defineProperty(this, \"fallbackStrategy\", void 0);\n      _defineProperty(this, \"langChanges$\", void 0);\n      _defineProperty(this, \"subscription\", null);\n      _defineProperty(this, \"translations\", new Map());\n      _defineProperty(this, \"cache\", new Map());\n      _defineProperty(this, \"firstFallbackLang\", void 0);\n      _defineProperty(this, \"defaultLang\", '');\n      _defineProperty(this, \"availableLangs\", []);\n      _defineProperty(this, \"isResolvedMissingOnce\", false);\n      _defineProperty(this, \"lang\", void 0);\n      _defineProperty(this, \"failedLangs\", new Set());\n      _defineProperty(this, \"events\", new Subject());\n      _defineProperty(this, \"events$\", this.events.asObservable());\n      _defineProperty(this, \"config\", void 0);\n      this.loader = loader;\n      this.parser = parser;\n      this.missingHandler = missingHandler;\n      this.interceptor = interceptor;\n      this.fallbackStrategy = fallbackStrategy;\n      if (!this.loader) {\n        this.loader = new DefaultLoader(this.translations);\n      }\n      service = this;\n      this.config = JSON.parse(JSON.stringify(userConfig));\n      this.setAvailableLangs(this.config.availableLangs || []);\n      this.setFallbackLangForMissingTranslation(this.config);\n      this.setDefaultLang(this.config.defaultLang);\n      this.lang = new BehaviorSubject(this.getDefaultLang());\n      // Don't use distinctUntilChanged as we need the ability to update\n      // the value when using setTranslation or setTranslationKeys\n      this.langChanges$ = this.lang.asObservable();\n      /**\n       * When we have a failure, we want to define the next language that succeeded as the active\n       */\n      this.subscription = this.events$.subscribe(e => {\n        if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n          this.setActiveLang(e.payload.langName);\n        }\n      });\n    }\n    getDefaultLang() {\n      return this.defaultLang;\n    }\n    setDefaultLang(lang) {\n      this.defaultLang = lang;\n    }\n    getActiveLang() {\n      return this.lang.getValue();\n    }\n    setActiveLang(lang) {\n      this.parser.onLangChanged?.(lang);\n      this.lang.next(lang);\n      this.events.next({\n        type: 'langChanged',\n        payload: getEventPayload(lang)\n      });\n      return this;\n    }\n    setAvailableLangs(langs) {\n      this.availableLangs = langs;\n    }\n    /**\n     * Gets the available languages.\n     *\n     * @returns\n     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n     * depending on how the available languages are set in your module.\n     */\n    getAvailableLangs() {\n      return this.availableLangs;\n    }\n    load(path, options = {}) {\n      const cached = this.cache.get(path);\n      if (cached) {\n        return cached;\n      }\n      let loadTranslation;\n      const isScope = this._isLangScoped(path);\n      let scope;\n      if (isScope) {\n        scope = getScopeFromLang(path);\n      }\n      const loadersOptions = {\n        path,\n        mainLoader: this.loader,\n        inlineLoader: options.inlineLoader,\n        data: isScope ? {\n          scope: scope\n        } : undefined\n      };\n      if (this.useFallbackTranslation(path)) {\n        // if the path is scope the fallback should be `scope/fallbackLang`;\n        const fallback = isScope ? `${scope}/${this.firstFallbackLang}` : this.firstFallbackLang;\n        const loaders = getFallbacksLoaders({\n          ...loadersOptions,\n          fallbackPath: fallback\n        });\n        loadTranslation = forkJoin(loaders);\n      } else {\n        const loader = resolveLoader(loadersOptions);\n        loadTranslation = from(loader);\n      }\n      const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap(translation => {\n        if (Array.isArray(translation)) {\n          translation.forEach(t => {\n            this.handleSuccess(t.lang, t.translation);\n            // Save the fallback in cache so we'll not create a redundant request\n            if (t.lang !== path) {\n              this.cache.set(t.lang, of({}));\n            }\n          });\n          return;\n        }\n        this.handleSuccess(path, translation);\n      }), catchError(error => {\n        if (!this.config.prodMode) {\n          console.error(`Error while trying to load \"${path}\"`, error);\n        }\n        return this.handleFailure(path, options);\n      }), shareReplay(1));\n      this.cache.set(path, load$);\n      return load$;\n    }\n    /**\n     * Gets the instant translated value of a key\n     *\n     * @example\n     *\n     * translate<string>('hello')\n     * translate('hello', { value: 'value' })\n     * translate<string[]>(['hello', 'key'])\n     * translate('hello', { }, 'en')\n     * translate('scope.someKey', { }, 'en')\n     */\n    translate(key, params = {}, lang = this.getActiveLang()) {\n      if (!key) return key;\n      const {\n        scope,\n        resolveLang\n      } = this.resolveLangAndScope(lang);\n      if (Array.isArray(key)) {\n        return key.map(k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang));\n      }\n      key = scope ? `${scope}.${key}` : key;\n      const translation = this.getTranslation(resolveLang);\n      const value = translation[key];\n      if (!value) {\n        return this._handleMissingKey(key, value, params);\n      }\n      return this.parser.transpile(value, params, translation, key);\n    }\n    /**\n     * Gets the translated value of a key as observable\n     *\n     * @example\n     *\n     * selectTranslate<string>('hello').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n     *\n     */\n    selectTranslate(key, params, lang, _isObject = false) {\n      let inlineLoader;\n      const load = (lang, options) => this.load(lang, options).pipe(map(() => _isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang)));\n      if (isNil(lang)) {\n        return this.langChanges$.pipe(switchMap(lang => load(lang)));\n      }\n      if (isScopeArray(lang) || isScopeObject(lang)) {\n        // it's a scope object.\n        const providerScope = Array.isArray(lang) ? lang[0] : lang;\n        lang = providerScope.scope;\n        inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n      }\n      lang = lang;\n      if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n        return load(lang);\n      }\n      // it's a scope\n      const scope = lang;\n      return this.langChanges$.pipe(switchMap(lang => load(`${scope}/${lang}`, {\n        inlineLoader\n      })));\n    }\n    /**\n     * Whether the scope with lang\n     *\n     * @example\n     *\n     * todos/en => true\n     * todos => false\n     */\n    isScopeWithLang(lang) {\n      return this.isLang(getLangFromScope(lang));\n    }\n    translateObject(key, params = {}, lang = this.getActiveLang()) {\n      if (isString(key) || Array.isArray(key)) {\n        const {\n          resolveLang,\n          scope\n        } = this.resolveLangAndScope(lang);\n        if (Array.isArray(key)) {\n          return key.map(k => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang));\n        }\n        const translation = this.getTranslation(resolveLang);\n        key = scope ? `${scope}.${key}` : key;\n        const value = unflatten(this.getObjectByKey(translation, key));\n        /* If an empty object was returned we want to try and translate the key as a string and not an object */\n        return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation, key);\n      }\n      const translations = [];\n      for (const [_key, _params] of this.getEntries(key)) {\n        translations.push(this.translateObject(_key, _params, lang));\n      }\n      return translations;\n    }\n    selectTranslateObject(key, params, lang) {\n      if (isString(key) || Array.isArray(key)) {\n        return this.selectTranslate(key, params, lang, true);\n      }\n      const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n      /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n       * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n      return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map(value => {\n        const translations = [value];\n        for (const [_key, _params] of rest) {\n          translations.push(this.translateObject(_key, _params, lang));\n        }\n        return translations;\n      }));\n    }\n    getTranslation(langOrScope) {\n      if (langOrScope) {\n        if (this.isLang(langOrScope)) {\n          return this.translations.get(langOrScope) || {};\n        } else {\n          // This is a scope, build the scope value from the translation object\n          const {\n            scope,\n            resolveLang\n          } = this.resolveLangAndScope(langOrScope);\n          const translation = this.translations.get(resolveLang) || {};\n          return this.getObjectByKey(translation, scope);\n        }\n      }\n      return this.translations;\n    }\n    /**\n     * Gets an object of translations for a given language\n     *\n     * @example\n     *\n     * selectTranslation().subscribe() - will return the current lang translation\n     * selectTranslation('es').subscribe()\n     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n     * selectTranslation('admin-page/es').subscribe()\n     */\n    selectTranslation(lang) {\n      let language$ = this.langChanges$;\n      if (lang) {\n        const scopeLangSpecified = getLangFromScope(lang) !== lang;\n        if (this.isLang(lang) || scopeLangSpecified) {\n          language$ = of(lang);\n        } else {\n          language$ = this.langChanges$.pipe(map(currentLang => `${lang}/${currentLang}`));\n        }\n      }\n      return language$.pipe(switchMap(language => this.load(language).pipe(map(() => this.getTranslation(language)))));\n    }\n    /**\n     * Sets or merge a given translation object to current lang\n     *\n     * @example\n     *\n     * setTranslation({ ... })\n     * setTranslation({ ... }, 'en')\n     * setTranslation({ ... }, 'es', { merge: false } )\n     * setTranslation({ ... }, 'todos/en', { merge: false } )\n     */\n    setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n      const defaults = {\n        merge: true,\n        emitChange: true\n      };\n      const mergedOptions = {\n        ...defaults,\n        ...options\n      };\n      const scope = getScopeFromLang(lang);\n      /**\n       * If this isn't a scope we use the whole translation as is\n       * otherwise we need to flat the scope and use it\n       */\n      let flattenScopeOrTranslation = translation;\n      // Merged the scoped language into the active language\n      if (scope) {\n        const key = this.getMappedScope(scope);\n        flattenScopeOrTranslation = flatten({\n          [key]: translation\n        });\n      }\n      const currentLang = scope ? getLangFromScope(lang) : lang;\n      const mergedTranslation = {\n        ...(mergedOptions.merge && this.getTranslation(currentLang)),\n        ...flattenScopeOrTranslation\n      };\n      const flattenTranslation = this.config.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n      const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n      this.translations.set(currentLang, withHook);\n      mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n    }\n    /**\n     * Sets translation key with given value\n     *\n     * @example\n     *\n     * setTranslationKey('key', 'value')\n     * setTranslationKey('key.nested', 'value')\n     * setTranslationKey('key.nested', 'value', 'en')\n     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n     */\n    setTranslationKey(key, value,\n    // Todo: Add the lang to the options in v3\n    lang = this.getActiveLang(), options = {}) {\n      const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n      const newValue = {\n        [key]: withHook\n      };\n      this.setTranslation(newValue, lang, {\n        ...options,\n        merge: true\n      });\n    }\n    /**\n     * Sets the fallback lang for the currently active language\n     * @param fallbackLang\n     */\n    setFallbackLangForMissingTranslation({\n      fallbackLang\n    }) {\n      const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n      if (fallbackLang && this.useFallbackTranslation(lang)) {\n        this.firstFallbackLang = lang;\n      }\n    }\n    /**\n     * @internal\n     */\n    _handleMissingKey(key, value, params) {\n      if (this.config.missingHandler.allowEmpty && value === '') {\n        return '';\n      }\n      if (!this.isResolvedMissingOnce && this.useFallbackTranslation()) {\n        // We need to set it to true to prevent a loop\n        this.isResolvedMissingOnce = true;\n        const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n        this.isResolvedMissingOnce = false;\n        return fallbackValue;\n      }\n      return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n    }\n    /**\n     * @internal\n     */\n    _isLangScoped(lang) {\n      return this.getAvailableLangsIds().indexOf(lang) === -1;\n    }\n    /**\n     * Checks if a given string is one of the specified available languages.\n     * @returns\n     * True if the given string is an available language.\n     * False if the given string is not an available language.\n     */\n    isLang(lang) {\n      return this.getAvailableLangsIds().indexOf(lang) !== -1;\n    }\n    /**\n     * @internal\n     *\n     * We always want to make sure the global lang is loaded\n     * before loading the scope since you can access both via the pipe/directive.\n     */\n    _loadDependencies(path, inlineLoader) {\n      const mainLang = getLangFromScope(path);\n      if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n        return combineLatest([this.load(mainLang), this.load(path, {\n          inlineLoader\n        })]);\n      }\n      return this.load(path, {\n        inlineLoader\n      });\n    }\n    /**\n     * @internal\n     */\n    _completeScopeWithLang(langOrScope) {\n      if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {\n        return `${langOrScope}/${this.getActiveLang()}`;\n      }\n      return langOrScope;\n    }\n    /**\n     * @internal\n     */\n    _setScopeAlias(scope, alias) {\n      if (!this.config.scopeMapping) {\n        this.config.scopeMapping = {};\n      }\n      this.config.scopeMapping[scope] = alias;\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n        // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n        // callback within its `destination` property, preventing classes from being GC'd.\n        this.subscription = null;\n      }\n      // Caretaker note: since this is the root provider, it'll be destroyed when the `NgModuleRef.destroy()` is run.\n      // Cached values capture `this`, thus leading to a circular reference and preventing the `TranslocoService` from\n      // being GC'd. This would lead to a memory leak when server-side rendering is used since the service is created\n      // and destroyed per each HTTP request, but any service is not getting GC'd.\n      this.cache.clear();\n    }\n    isLoadedTranslation(lang) {\n      return size(this.getTranslation(lang));\n    }\n    getAvailableLangsIds() {\n      const first = this.getAvailableLangs()[0];\n      if (isString(first)) {\n        return this.getAvailableLangs();\n      }\n      return this.getAvailableLangs().map(l => l.id);\n    }\n    getMissingHandlerData() {\n      return {\n        ...this.config,\n        activeLang: this.getActiveLang(),\n        availableLangs: this.availableLangs,\n        defaultLang: this.defaultLang\n      };\n    }\n    /**\n     * Use a fallback translation set for missing keys of the primary language\n     * This is unrelated to the fallback language (which changes the active language)\n     */\n    useFallbackTranslation(lang) {\n      return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n    }\n    handleSuccess(lang, translation) {\n      this.setTranslation(translation, lang, {\n        emitChange: false\n      });\n      this.events.next({\n        wasFailure: !!this.failedLangs.size,\n        type: 'translationLoadSuccess',\n        payload: getEventPayload(lang)\n      });\n      this.failedLangs.forEach(l => this.cache.delete(l));\n      this.failedLangs.clear();\n    }\n    handleFailure(lang, loadOptions) {\n      // When starting to load a first choice language, initialize\n      // the failed counter and resolve the fallback langs.\n      if (isNil(loadOptions.failedCounter)) {\n        loadOptions.failedCounter = 0;\n        if (!loadOptions.fallbackLangs) {\n          loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n        }\n      }\n      const splitted = lang.split('/');\n      const fallbacks = loadOptions.fallbackLangs;\n      const nextLang = fallbacks[loadOptions.failedCounter];\n      this.failedLangs.add(lang);\n      // This handles the case where a loaded fallback language is requested again\n      if (this.cache.has(nextLang)) {\n        this.handleSuccess(nextLang, this.getTranslation(nextLang));\n        return EMPTY;\n      }\n      const isFallbackLang = nextLang === splitted[splitted.length - 1];\n      if (!nextLang || isFallbackLang) {\n        let msg = `Unable to load translation and all the fallback languages`;\n        if (splitted.length > 1) {\n          msg += `, did you misspelled the scope name?`;\n        }\n        throw new Error(msg);\n      }\n      let resolveLang = nextLang;\n      // if it's scoped lang\n      if (splitted.length > 1) {\n        // We need to resolve it to:\n        // todos/langNotExists => todos/nextLang\n        splitted[splitted.length - 1] = nextLang;\n        resolveLang = splitted.join('/');\n      }\n      loadOptions.failedCounter++;\n      this.events.next({\n        type: 'translationLoadFailure',\n        payload: getEventPayload(lang)\n      });\n      return this.load(resolveLang, loadOptions);\n    }\n    getMappedScope(scope) {\n      const {\n        scopeMapping = {}\n      } = this.config;\n      return scopeMapping[scope] || toCamelCase(scope);\n    }\n    /**\n     * If lang is scope we need to check the following cases:\n     * todos/es => in this case we should take `es` as lang\n     * todos => in this case we should set the active lang as lang\n     */\n    resolveLangAndScope(lang) {\n      let resolveLang = lang;\n      let scope;\n      if (this._isLangScoped(lang)) {\n        // en for example\n        const langFromScope = getLangFromScope(lang);\n        // en is lang\n        const hasLang = this.isLang(langFromScope);\n        // take en\n        resolveLang = hasLang ? langFromScope : this.getActiveLang();\n        // find the scope\n        scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n      }\n      return {\n        scope,\n        resolveLang\n      };\n    }\n    getObjectByKey(translation, key) {\n      const result = {};\n      const prefix = `${key}.`;\n      for (const currentKey in translation) {\n        if (currentKey.startsWith(prefix)) {\n          result[currentKey.replace(prefix, '')] = translation[currentKey];\n        }\n      }\n      return result;\n    }\n    getEntries(key) {\n      return key instanceof Map ? key.entries() : Object.entries(key);\n    }\n  }\n  _class7 = TranslocoService;\n  _defineProperty(TranslocoService, \"\\u0275fac\", function _class7_Factory(t) {\n    return new (t || _class7)(i0.ɵɵinject(TRANSLOCO_LOADER, 8), i0.ɵɵinject(TRANSLOCO_TRANSPILER), i0.ɵɵinject(TRANSLOCO_MISSING_HANDLER), i0.ɵɵinject(TRANSLOCO_INTERCEPTOR), i0.ɵɵinject(TRANSLOCO_CONFIG), i0.ɵɵinject(TRANSLOCO_FALLBACK_STRATEGY));\n  });\n  _defineProperty(TranslocoService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class7,\n    factory: _class7.ɵfac,\n    providedIn: 'root'\n  }));\n  return TranslocoService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TranslocoLoaderComponent = /*#__PURE__*/(() => {\n  var _class8;\n  class TranslocoLoaderComponent {\n    constructor() {\n      _defineProperty(this, \"html\", void 0);\n    }\n  }\n  _class8 = TranslocoLoaderComponent;\n  _defineProperty(TranslocoLoaderComponent, \"\\u0275fac\", function _class8_Factory(t) {\n    return new (t || _class8)();\n  });\n  _defineProperty(TranslocoLoaderComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class8,\n    selectors: [[\"ng-component\"]],\n    inputs: {\n      html: \"html\"\n    },\n    standalone: true,\n    features: [i0.ɵɵStandaloneFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[1, \"transloco-loader-template\", 3, \"innerHTML\"]],\n    template: function _class8_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHTML\", ctx.html, i0.ɵɵsanitizeHtml);\n      }\n    },\n    encapsulation: 2\n  }));\n  return TranslocoLoaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass TemplateHandler {\n  constructor(view, vcr) {\n    _defineProperty(this, \"view\", void 0);\n    _defineProperty(this, \"vcr\", void 0);\n    this.view = view;\n    this.vcr = vcr;\n  }\n  attachView() {\n    if (this.view instanceof TemplateRef) {\n      this.vcr.createEmbeddedView(this.view);\n    } else if (isString(this.view)) {\n      const componentRef = this.vcr.createComponent(TranslocoLoaderComponent);\n      componentRef.instance.html = this.view;\n      componentRef.hostView.detectChanges();\n    } else {\n      this.vcr.createComponent(this.view);\n    }\n  }\n  detachView() {\n    this.vcr.clear();\n  }\n}\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\nclass LangResolver {\n  constructor() {\n    _defineProperty(this, \"initialized\", false);\n  }\n  // inline => provider => active\n  resolve({\n    inline,\n    provider,\n    active\n  }) {\n    let lang = active;\n    /**\n     * When the user changes the lang we need to update\n     * the view. Otherwise, the lang will remain the inline/provided lang\n     */\n    if (this.initialized) {\n      lang = active;\n      return lang;\n    }\n    if (provider) {\n      const [, extracted] = getPipeValue(provider, 'static');\n      lang = extracted;\n    }\n    if (inline) {\n      const [, extracted] = getPipeValue(inline, 'static');\n      lang = extracted;\n    }\n    this.initialized = true;\n    return lang;\n  }\n  /**\n   *\n   * Resolve the lang\n   *\n   * @example\n   *\n   * resolveLangBasedOnScope('todos/en') => en\n   * resolveLangBasedOnScope('en') => en\n   *\n   */\n  resolveLangBasedOnScope(lang) {\n    const scope = getScopeFromLang(lang);\n    return scope ? getLangFromScope(lang) : lang;\n  }\n  /**\n   *\n   * Resolve the lang path for loading\n   *\n   * @example\n   *\n   * resolveLangPath('todos', 'en') => todos/en\n   * resolveLangPath('en') => en\n   *\n   */\n  resolveLangPath(lang, scope) {\n    return scope ? `${scope}/${lang}` : lang;\n  }\n}\nclass ScopeResolver {\n  constructor(service) {\n    _defineProperty(this, \"service\", void 0);\n    this.service = service;\n  }\n  // inline => provider\n  resolve(params) {\n    const {\n      inline,\n      provider\n    } = params;\n    if (inline) {\n      return inline;\n    }\n    if (provider) {\n      if (isScopeObject(provider)) {\n        const {\n          scope,\n          alias = toCamelCase(scope)\n        } = provider;\n        this.service._setScopeAlias(scope, alias);\n        return scope;\n      }\n      return provider;\n    }\n    return undefined;\n  }\n}\nlet TranslocoDirective = /*#__PURE__*/(() => {\n  var _class12;\n  class TranslocoDirective {\n    constructor() {\n      _defineProperty(this, \"service\", inject(TranslocoService));\n      _defineProperty(this, \"tpl\", inject(TemplateRef, {\n        optional: true\n      }));\n      _defineProperty(this, \"providerLang\", inject(TRANSLOCO_LANG, {\n        optional: true\n      }));\n      _defineProperty(this, \"providerScope\", inject(TRANSLOCO_SCOPE, {\n        optional: true\n      }));\n      _defineProperty(this, \"providedLoadingTpl\", inject(TRANSLOCO_LOADING_TEMPLATE, {\n        optional: true\n      }));\n      _defineProperty(this, \"cdr\", inject(ChangeDetectorRef));\n      _defineProperty(this, \"host\", inject(ElementRef));\n      _defineProperty(this, \"vcr\", inject(ViewContainerRef));\n      _defineProperty(this, \"renderer\", inject(Renderer2));\n      _defineProperty(this, \"subscription\", null);\n      _defineProperty(this, \"view\", void 0);\n      _defineProperty(this, \"translationMemo\", {});\n      _defineProperty(this, \"key\", void 0);\n      _defineProperty(this, \"params\", {});\n      _defineProperty(this, \"inlineScope\", void 0);\n      _defineProperty(this, \"inlineRead\", void 0);\n      _defineProperty(this, \"inlineLang\", void 0);\n      _defineProperty(this, \"inlineTpl\", void 0);\n      _defineProperty(this, \"currentLang\", void 0);\n      _defineProperty(this, \"loaderTplHandler\", void 0);\n      // Whether we already rendered the view once\n      _defineProperty(this, \"initialized\", false);\n      _defineProperty(this, \"path\", void 0);\n      _defineProperty(this, \"langResolver\", new LangResolver());\n      _defineProperty(this, \"scopeResolver\", new ScopeResolver(this.service));\n      _defineProperty(this, \"strategy\", this.tpl === null ? 'attribute' : 'structural');\n    }\n    static ngTemplateContextGuard(dir, ctx) {\n      return true;\n    }\n    ngOnInit() {\n      const listenToLangChange = shouldListenToLangChanges(this.service, this.providerLang || this.inlineLang);\n      this.subscription = this.service.langChanges$.pipe(switchMap(activeLang => {\n        const lang = this.langResolver.resolve({\n          inline: this.inlineLang,\n          provider: this.providerLang,\n          active: activeLang\n        });\n        return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n      }), listenOrNotOperator(listenToLangChange)).subscribe(() => {\n        this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.strategy === 'attribute' ? this.attributeStrategy() : this.structuralStrategy(this.currentLang, this.inlineRead);\n        this.cdr.markForCheck();\n        this.initialized = true;\n      });\n      if (!this.initialized) {\n        const loadingContent = this.resolveLoadingContent();\n        if (loadingContent) {\n          this.loaderTplHandler = new TemplateHandler(loadingContent, this.vcr);\n          this.loaderTplHandler.attachView();\n        }\n      }\n    }\n    ngOnChanges(changes) {\n      // We need to support dynamic keys/params, so if this is not the first change CD cycle\n      // we need to run the function again in order to update the value\n      if (this.strategy === 'attribute') {\n        const notInit = Object.keys(changes).some(v => !changes[v].firstChange);\n        notInit && this.attributeStrategy();\n      }\n    }\n    attributeStrategy() {\n      this.detachLoader();\n      this.renderer.setProperty(this.host.nativeElement, 'innerText', this.service.translate(this.key, this.params, this.currentLang));\n    }\n    structuralStrategy(lang, read) {\n      this.translationMemo = {};\n      if (this.view) {\n        // when the lang changes we need to change the reference so Angular will update the view\n        this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n        this.view.context['currentLang'] = this.currentLang;\n      } else {\n        this.detachLoader();\n        this.view = this.vcr.createEmbeddedView(this.tpl, {\n          $implicit: this.getTranslateFn(lang, read),\n          currentLang: this.currentLang\n        });\n      }\n    }\n    getTranslateFn(lang, read) {\n      return (key, params) => {\n        const withRead = read ? `${read}.${key}` : key;\n        const withParams = params ? `${withRead}${JSON.stringify(params)}` : withRead;\n        if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {\n          return this.translationMemo[withParams].value;\n        }\n        this.translationMemo[withParams] = {\n          params,\n          value: this.service.translate(withRead, params, lang)\n        };\n        return this.translationMemo[withParams].value;\n      };\n    }\n    resolveLoadingContent() {\n      return this.inlineTpl || this.providedLoadingTpl;\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n        // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n        // callback within its `destination` property, preventing classes from being GC'd.\n        this.subscription = null;\n      }\n    }\n    detachLoader() {\n      this.loaderTplHandler?.detachView();\n    }\n    resolveScope(lang, providerScope) {\n      const resolvedScope = this.scopeResolver.resolve({\n        inline: this.inlineScope,\n        provider: providerScope\n      });\n      this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n      const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n      return this.service._loadDependencies(this.path, inlineLoader);\n    }\n  }\n  _class12 = TranslocoDirective;\n  _defineProperty(TranslocoDirective, \"\\u0275fac\", function _class12_Factory(t) {\n    return new (t || _class12)();\n  });\n  _defineProperty(TranslocoDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class12,\n    selectors: [[\"\", \"transloco\", \"\"]],\n    inputs: {\n      key: [\"transloco\", \"key\"],\n      params: [\"translocoParams\", \"params\"],\n      inlineScope: [\"translocoScope\", \"inlineScope\"],\n      inlineRead: [\"translocoRead\", \"inlineRead\"],\n      inlineLang: [\"translocoLang\", \"inlineLang\"],\n      inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  }));\n  return TranslocoDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TranslocoPipe = /*#__PURE__*/(() => {\n  var _class13;\n  class TranslocoPipe {\n    constructor(service, providerScope, providerLang, cdr) {\n      _defineProperty(this, \"service\", void 0);\n      _defineProperty(this, \"providerScope\", void 0);\n      _defineProperty(this, \"providerLang\", void 0);\n      _defineProperty(this, \"cdr\", void 0);\n      _defineProperty(this, \"subscription\", null);\n      _defineProperty(this, \"lastValue\", '');\n      _defineProperty(this, \"lastKey\", void 0);\n      _defineProperty(this, \"path\", void 0);\n      _defineProperty(this, \"langResolver\", new LangResolver());\n      _defineProperty(this, \"scopeResolver\", void 0);\n      this.service = service;\n      this.providerScope = providerScope;\n      this.providerLang = providerLang;\n      this.cdr = cdr;\n      this.scopeResolver = new ScopeResolver(this.service);\n    }\n    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n    // null is for handling strict mode + optional chaining types https://github.com/ngneat/transloco/issues/488\n    transform(key, params, inlineLang) {\n      if (!key) {\n        return key;\n      }\n      const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n      if (keyName === this.lastKey) {\n        return this.lastValue;\n      }\n      this.lastKey = keyName;\n      this.subscription?.unsubscribe();\n      const listenToLangChange = shouldListenToLangChanges(this.service, this.providerLang || inlineLang);\n      this.subscription = this.service.langChanges$.pipe(switchMap(activeLang => {\n        const lang = this.langResolver.resolve({\n          inline: inlineLang,\n          provider: this.providerLang,\n          active: activeLang\n        });\n        return Array.isArray(this.providerScope) ? forkJoin(this.providerScope.map(providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n      }), listenOrNotOperator(listenToLangChange)).subscribe(() => this.updateValue(key, params));\n      return this.lastValue;\n    }\n    ngOnDestroy() {\n      this.subscription?.unsubscribe();\n      // Caretaker note: it's important to clean up references to subscriptions since they save the `next`\n      // callback within its `destination` property, preventing classes from being GC'd.\n      this.subscription = null;\n    }\n    updateValue(key, params) {\n      const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n      this.lastValue = this.service.translate(key, params, lang);\n      this.cdr.markForCheck();\n    }\n    resolveScope(lang, providerScope) {\n      const resolvedScope = this.scopeResolver.resolve({\n        inline: undefined,\n        provider: providerScope\n      });\n      this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n      const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n      return this.service._loadDependencies(this.path, inlineLoader);\n    }\n  }\n  _class13 = TranslocoPipe;\n  _defineProperty(TranslocoPipe, \"\\u0275fac\", function _class13_Factory(t) {\n    return new (t || _class13)(i0.ɵɵdirectiveInject(TranslocoService, 16), i0.ɵɵdirectiveInject(TRANSLOCO_SCOPE, 24), i0.ɵɵdirectiveInject(TRANSLOCO_LANG, 24), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n  });\n  _defineProperty(TranslocoPipe, \"\\u0275pipe\", /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"transloco\",\n    type: _class13,\n    pure: false,\n    standalone: true\n  }));\n  return TranslocoPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst decl = [TranslocoDirective, TranslocoPipe];\nlet TranslocoModule = /*#__PURE__*/(() => {\n  var _class14;\n  class TranslocoModule {}\n  _class14 = TranslocoModule;\n  _defineProperty(TranslocoModule, \"\\u0275fac\", function _class14_Factory(t) {\n    return new (t || _class14)();\n  });\n  _defineProperty(TranslocoModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class14\n  }));\n  _defineProperty(TranslocoModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({}));\n  return TranslocoModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideTransloco(options) {\n  const providers = [provideTranslocoTranspiler(DefaultTranspiler), provideTranslocoMissingHandler(DefaultHandler), provideTranslocoInterceptor(DefaultInterceptor), provideTranslocoFallbackStrategy(DefaultFallbackStrategy)];\n  if (options.config) {\n    providers.push(provideTranslocoConfig(options.config));\n  }\n  if (options.loader) {\n    providers.push(provideTranslocoLoader(options.loader));\n  }\n  return providers;\n}\nfunction provideTranslocoConfig(config) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_CONFIG,\n    useValue: translocoConfig(config)\n  }]);\n}\nfunction provideTranslocoLoader(loader) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_LOADER,\n    useClass: loader\n  }]);\n}\nfunction provideTranslocoScope(scope) {\n  return {\n    provide: TRANSLOCO_SCOPE,\n    useValue: scope,\n    multi: true\n  };\n}\nfunction provideTranslocoLoadingTpl(content) {\n  return {\n    provide: TRANSLOCO_LOADING_TEMPLATE,\n    useValue: content\n  };\n}\nfunction provideTranslocoTranspiler(transpiler) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_TRANSPILER,\n    useClass: transpiler,\n    deps: [TRANSLOCO_CONFIG]\n  }]);\n}\nfunction provideTranslocoFallbackStrategy(strategy) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_FALLBACK_STRATEGY,\n    useClass: strategy,\n    deps: [TRANSLOCO_CONFIG]\n  }]);\n}\nfunction provideTranslocoMissingHandler(handler) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_MISSING_HANDLER,\n    useClass: handler\n  }]);\n}\nfunction provideTranslocoInterceptor(interceptor) {\n  return makeEnvironmentProviders([{\n    provide: TRANSLOCO_INTERCEPTOR,\n    useClass: interceptor\n  }]);\n}\nfunction provideTranslocoLang(lang) {\n  return {\n    provide: TRANSLOCO_LANG,\n    useValue: lang\n  };\n}\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\nlet TestingLoader = /*#__PURE__*/(() => {\n  var _class15;\n  class TestingLoader {\n    constructor(langs) {\n      _defineProperty(this, \"langs\", void 0);\n      this.langs = langs;\n    }\n    getTranslation(lang) {\n      return of(this.langs[lang]);\n    }\n  }\n  _class15 = TestingLoader;\n  _defineProperty(TestingLoader, \"\\u0275fac\", function _class15_Factory(t) {\n    return new (t || _class15)(i0.ɵɵinject(TRANSLOCO_TEST_LANGS));\n  });\n  _defineProperty(TestingLoader, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class15,\n    factory: _class15.ɵfac\n  }));\n  return TestingLoader;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction initTranslocoService(service, langs = {}, options) {\n  const preloadAllLangs = () => options.preloadLangs ? Promise.all(Object.keys(langs).map(lang => service.load(lang).toPromise())) : Promise.resolve();\n  return preloadAllLangs;\n}\nlet TranslocoTestingModule = /*#__PURE__*/(() => {\n  var _class16;\n  class TranslocoTestingModule {\n    static forRoot(options) {\n      return {\n        ngModule: TranslocoTestingModule,\n        providers: [provideTransloco({\n          loader: TestingLoader,\n          config: {\n            prodMode: true,\n            missingHandler: {\n              logMissingKey: false\n            },\n            ...options.translocoConfig\n          }\n        }), {\n          provide: TRANSLOCO_TEST_LANGS,\n          useValue: options.langs\n        }, {\n          provide: TRANSLOCO_TEST_OPTIONS,\n          useValue: options\n        }, {\n          provide: APP_INITIALIZER,\n          useFactory: initTranslocoService,\n          deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n          multi: true\n        }]\n      };\n    }\n  }\n  _class16 = TranslocoTestingModule;\n  _defineProperty(TranslocoTestingModule, \"\\u0275fac\", function _class16_Factory(t) {\n    return new (t || _class16)();\n  });\n  _defineProperty(TranslocoTestingModule, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class16\n  }));\n  _defineProperty(TranslocoTestingModule, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [TranslocoModule]\n  }));\n  return TranslocoTestingModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\nfunction getBrowserLang() {\n  let browserLang = getBrowserCultureLang();\n  if (!browserLang || !isBrowser()) {\n    return undefined;\n  }\n  if (browserLang.indexOf('-') !== -1) {\n    browserLang = browserLang.split('-')[0];\n  }\n  if (browserLang.indexOf('_') !== -1) {\n    browserLang = browserLang.split('_')[0];\n  }\n  return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\nfunction getBrowserCultureLang() {\n  if (!isBrowser()) {\n    return '';\n  }\n  const navigator = window.navigator;\n  return navigator.languages?.[0] ?? navigator.language;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DefaultFallbackStrategy, DefaultTranspiler, FunctionalTranspiler, TRANSLOCO_CONFIG, TRANSLOCO_FALLBACK_STRATEGY, TRANSLOCO_INTERCEPTOR, TRANSLOCO_LANG, TRANSLOCO_LOADER, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_MISSING_HANDLER, TRANSLOCO_SCOPE, TRANSLOCO_TRANSPILER, TestingLoader, TranslocoDirective, TranslocoModule, TranslocoPipe, TranslocoService, TranslocoTestingModule, coerceArray, defaultConfig, flatten, getBrowserCultureLang, getBrowserLang, getFunctionArgs, getLangFromScope, getPipeValue, getScopeFromLang, getValue, hasInlineLoader, isBrowser, isDefined, isEmpty, isFunction, isNil, isNumber, isObject, isScopeArray, isScopeObject, isString, provideTransloco, provideTranslocoConfig, provideTranslocoFallbackStrategy, provideTranslocoInterceptor, provideTranslocoLang, provideTranslocoLoader, provideTranslocoLoadingTpl, provideTranslocoMissingHandler, provideTranslocoScope, provideTranslocoTranspiler, setValue, size, toCamelCase, toNumber, translate, translateObject, translocoConfig, unflatten };\n//# sourceMappingURL=ngneat-transloco.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}