{"ast":null,"code":"import _asyncToGenerator from \"D:/r/class record/TDH APP/cyber-mobile/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nexport function resolveUrl(url, baseUrl) {\n  // url is absolute already\n  if (url.match(/^[a-z]+:\\/\\//i)) {\n    return url;\n  }\n  // url is absolute already, without protocol\n  if (url.match(/^\\/\\//)) {\n    return window.location.protocol + url;\n  }\n  // dataURI, mailto:, tel:, etc.\n  if (url.match(/^[a-z]+:/i)) {\n    return url;\n  }\n  const doc = document.implementation.createHTMLDocument();\n  const base = doc.createElement('base');\n  const a = doc.createElement('a');\n  doc.head.appendChild(base);\n  doc.body.appendChild(a);\n  if (baseUrl) {\n    base.href = baseUrl;\n  }\n  a.href = url;\n  return a.href;\n}\nexport const uuid = (() => {\n  // generate uuid for className of pseudo elements.\n  // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n  let counter = 0;\n  // ref: http://stackoverflow.com/a/6248722/2519373\n  const random = () =>\n  // eslint-disable-next-line no-bitwise\n  `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4);\n  return () => {\n    counter += 1;\n    return `u${random()}${counter}`;\n  };\n})();\nexport function delay(ms) {\n  return args => new Promise(resolve => {\n    setTimeout(() => resolve(args), ms);\n  });\n}\nexport function toArray(arrayLike) {\n  const arr = [];\n  for (let i = 0, l = arrayLike.length; i < l; i++) {\n    arr.push(arrayLike[i]);\n  }\n  return arr;\n}\nfunction px(node, styleProperty) {\n  const win = node.ownerDocument.defaultView || window;\n  const val = win.getComputedStyle(node).getPropertyValue(styleProperty);\n  return val ? parseFloat(val.replace('px', '')) : 0;\n}\nfunction getNodeWidth(node) {\n  const leftBorder = px(node, 'border-left-width');\n  const rightBorder = px(node, 'border-right-width');\n  return node.clientWidth + leftBorder + rightBorder;\n}\nfunction getNodeHeight(node) {\n  const topBorder = px(node, 'border-top-width');\n  const bottomBorder = px(node, 'border-bottom-width');\n  return node.clientHeight + topBorder + bottomBorder;\n}\nexport function getImageSize(targetNode, options = {}) {\n  const width = options.width || getNodeWidth(targetNode);\n  const height = options.height || getNodeHeight(targetNode);\n  return {\n    width,\n    height\n  };\n}\nexport function getPixelRatio() {\n  let ratio;\n  let FINAL_PROCESS;\n  try {\n    FINAL_PROCESS = process;\n  } catch (e) {\n    // pass\n  }\n  const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;\n  if (val) {\n    ratio = parseInt(val, 10);\n    if (Number.isNaN(ratio)) {\n      ratio = 1;\n    }\n  }\n  return ratio || window.devicePixelRatio || 1;\n}\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384;\nexport function checkCanvasDimensions(canvas) {\n  if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {\n    if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {\n      if (canvas.width > canvas.height) {\n        canvas.height *= canvasDimensionLimit / canvas.width;\n        canvas.width = canvasDimensionLimit;\n      } else {\n        canvas.width *= canvasDimensionLimit / canvas.height;\n        canvas.height = canvasDimensionLimit;\n      }\n    } else if (canvas.width > canvasDimensionLimit) {\n      canvas.height *= canvasDimensionLimit / canvas.width;\n      canvas.width = canvasDimensionLimit;\n    } else {\n      canvas.width *= canvasDimensionLimit / canvas.height;\n      canvas.height = canvasDimensionLimit;\n    }\n  }\n}\nexport function canvasToBlob(canvas, options = {}) {\n  if (canvas.toBlob) {\n    return new Promise(resolve => {\n      canvas.toBlob(resolve, options.type ? options.type : 'image/png', options.quality ? options.quality : 1);\n    });\n  }\n  return new Promise(resolve => {\n    const binaryString = window.atob(canvas.toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined).split(',')[1]);\n    const len = binaryString.length;\n    const binaryArray = new Uint8Array(len);\n    for (let i = 0; i < len; i += 1) {\n      binaryArray[i] = binaryString.charCodeAt(i);\n    }\n    resolve(new Blob([binaryArray], {\n      type: options.type ? options.type : 'image/png'\n    }));\n  });\n}\nexport function createImage(url) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.decode = () => resolve(img);\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.crossOrigin = 'anonymous';\n    img.decoding = 'async';\n    img.src = url;\n  });\n}\nexport function svgToDataURL(_x) {\n  return _svgToDataURL.apply(this, arguments);\n}\nfunction _svgToDataURL() {\n  _svgToDataURL = _asyncToGenerator(function* (svg) {\n    return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then(html => `data:image/svg+xml;charset=utf-8,${html}`);\n  });\n  return _svgToDataURL.apply(this, arguments);\n}\nexport function nodeToDataURL(_x2, _x3, _x4) {\n  return _nodeToDataURL.apply(this, arguments);\n}\nfunction _nodeToDataURL() {\n  _nodeToDataURL = _asyncToGenerator(function* (node, width, height) {\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n    svg.setAttribute('width', `${width}`);\n    svg.setAttribute('height', `${height}`);\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    foreignObject.setAttribute('width', '100%');\n    foreignObject.setAttribute('height', '100%');\n    foreignObject.setAttribute('x', '0');\n    foreignObject.setAttribute('y', '0');\n    foreignObject.setAttribute('externalResourcesRequired', 'true');\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(node);\n    return svgToDataURL(svg);\n  });\n  return _nodeToDataURL.apply(this, arguments);\n}\nexport const isInstanceOfElement = (node, instance) => {\n  if (node instanceof instance) return true;\n  const nodePrototype = Object.getPrototypeOf(node);\n  if (nodePrototype === null) return false;\n  return nodePrototype.constructor.name === instance.name || isInstanceOfElement(nodePrototype, instance);\n};\n//# sourceMappingURL=util.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}