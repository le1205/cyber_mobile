{"ast":null,"code":"import _asyncToGenerator from \"D:/r/class record/TDH APP/cyber-mobile/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { toArray } from './util';\nimport { fetchAsDataURL } from './dataurl';\nimport { shouldEmbed, embedResources } from './embed-resources';\nconst cssFetchCache = {};\nfunction fetchCSS(_x) {\n  return _fetchCSS.apply(this, arguments);\n}\nfunction _fetchCSS() {\n  _fetchCSS = _asyncToGenerator(function* (url) {\n    let cache = cssFetchCache[url];\n    if (cache != null) {\n      return cache;\n    }\n    const res = yield fetch(url);\n    const cssText = yield res.text();\n    cache = {\n      url,\n      cssText\n    };\n    cssFetchCache[url] = cache;\n    return cache;\n  });\n  return _fetchCSS.apply(this, arguments);\n}\nfunction embedFonts(_x2, _x3) {\n  return _embedFonts.apply(this, arguments);\n}\nfunction _embedFonts() {\n  _embedFonts = _asyncToGenerator(function* (data, options) {\n    let cssText = data.cssText;\n    const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n    const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n    const loadFonts = fontLocs.map( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (loc) {\n        let url = loc.replace(regexUrl, '$1');\n        if (!url.startsWith('https://')) {\n          url = new URL(url, data.url).href;\n        }\n        return fetchAsDataURL(url, options.fetchRequestInit, ({\n          result\n        }) => {\n          cssText = cssText.replace(loc, `url(${result})`);\n          return [loc, result];\n        });\n      });\n      return function (_x12) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    return Promise.all(loadFonts).then(() => cssText);\n  });\n  return _embedFonts.apply(this, arguments);\n}\nfunction parseCSS(source) {\n  if (source == null) {\n    return [];\n  }\n  const result = [];\n  const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n  // strip out comments\n  let cssText = source.replace(commentsRegex, '');\n  // eslint-disable-next-line prefer-regex-literals\n  const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi');\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matches = keyframesRegex.exec(cssText);\n    if (matches === null) {\n      break;\n    }\n    result.push(matches[0]);\n  }\n  cssText = cssText.replace(keyframesRegex, '');\n  const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n  // to match css & media queries together\n  const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' + '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})';\n  // unified regex\n  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let matches = importRegex.exec(cssText);\n    if (matches === null) {\n      matches = unifiedRegex.exec(cssText);\n      if (matches === null) {\n        break;\n      } else {\n        importRegex.lastIndex = unifiedRegex.lastIndex;\n      }\n    } else {\n      unifiedRegex.lastIndex = importRegex.lastIndex;\n    }\n    result.push(matches[0]);\n  }\n  return result;\n}\nfunction getCSSRules(_x4, _x5) {\n  return _getCSSRules.apply(this, arguments);\n}\nfunction _getCSSRules() {\n  _getCSSRules = _asyncToGenerator(function* (styleSheets, options) {\n    const ret = [];\n    const deferreds = [];\n    // First loop inlines imports\n    styleSheets.forEach(sheet => {\n      if ('cssRules' in sheet) {\n        try {\n          toArray(sheet.cssRules || []).forEach((item, index) => {\n            if (item.type === CSSRule.IMPORT_RULE) {\n              let importIndex = index + 1;\n              const url = item.href;\n              const deferred = fetchCSS(url).then(metadata => embedFonts(metadata, options)).then(cssText => parseCSS(cssText).forEach(rule => {\n                try {\n                  sheet.insertRule(rule, rule.startsWith('@import') ? importIndex += 1 : sheet.cssRules.length);\n                } catch (error) {\n                  console.error('Error inserting rule from remote css', {\n                    rule,\n                    error\n                  });\n                }\n              })).catch(e => {\n                console.error('Error loading remote css', e.toString());\n              });\n              deferreds.push(deferred);\n            }\n          });\n        } catch (e) {\n          const inline = styleSheets.find(a => a.href == null) || document.styleSheets[0];\n          if (sheet.href != null) {\n            deferreds.push(fetchCSS(sheet.href).then(metadata => embedFonts(metadata, options)).then(cssText => parseCSS(cssText).forEach(rule => {\n              inline.insertRule(rule, sheet.cssRules.length);\n            })).catch(err => {\n              console.error('Error loading remote stylesheet', err);\n            }));\n          }\n          console.error('Error inlining remote css file', e);\n        }\n      }\n    });\n    return Promise.all(deferreds).then(() => {\n      // Second loop parses rules\n      styleSheets.forEach(sheet => {\n        if ('cssRules' in sheet) {\n          try {\n            toArray(sheet.cssRules || []).forEach(item => {\n              ret.push(item);\n            });\n          } catch (e) {\n            console.error(`Error while reading CSS rules from ${sheet.href}`, e);\n          }\n        }\n      });\n      return ret;\n    });\n  });\n  return _getCSSRules.apply(this, arguments);\n}\nfunction getWebFontRules(cssRules) {\n  return cssRules.filter(rule => rule.type === CSSRule.FONT_FACE_RULE).filter(rule => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nfunction parseWebFontRules(_x6, _x7) {\n  return _parseWebFontRules.apply(this, arguments);\n}\nfunction _parseWebFontRules() {\n  _parseWebFontRules = _asyncToGenerator(function* (node, options) {\n    if (node.ownerDocument == null) {\n      throw new Error('Provided element is not within a Document');\n    }\n    const styleSheets = toArray(node.ownerDocument.styleSheets);\n    const cssRules = yield getCSSRules(styleSheets, options);\n    return getWebFontRules(cssRules);\n  });\n  return _parseWebFontRules.apply(this, arguments);\n}\nexport function getWebFontCSS(_x8, _x9) {\n  return _getWebFontCSS.apply(this, arguments);\n}\nfunction _getWebFontCSS() {\n  _getWebFontCSS = _asyncToGenerator(function* (node, options) {\n    const rules = yield parseWebFontRules(node, options);\n    const cssTexts = yield Promise.all(rules.map(rule => {\n      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n      return embedResources(rule.cssText, baseUrl, options);\n    }));\n    return cssTexts.join('\\n');\n  });\n  return _getWebFontCSS.apply(this, arguments);\n}\nexport function embedWebFonts(_x10, _x11) {\n  return _embedWebFonts.apply(this, arguments);\n}\n//# sourceMappingURL=embed-webfonts.js.map\nfunction _embedWebFonts() {\n  _embedWebFonts = _asyncToGenerator(function* (clonedNode, options) {\n    const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : yield getWebFontCSS(clonedNode, options);\n    if (cssText) {\n      const styleNode = document.createElement('style');\n      const sytleContent = document.createTextNode(cssText);\n      styleNode.appendChild(sytleContent);\n      if (clonedNode.firstChild) {\n        clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n      } else {\n        clonedNode.appendChild(styleNode);\n      }\n    }\n  });\n  return _embedWebFonts.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}